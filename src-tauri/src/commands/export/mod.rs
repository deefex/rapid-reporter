mod assets;
mod markdown;

use crate::models::Session;
use chrono::{Local, TimeZone};
use std::fs;

/// Exports an in-memory test session to a portable markdown report in the user's home directory.
///
/// The export folder contains the markdown file plus copied icons/screenshots under `assets/`.
#[tauri::command]
pub(crate) fn export_session_markdown(
    session: Session,
) -> Result<std::collections::HashMap<String, String>, String> {
    use std::collections::HashMap;

    let home = dirs::home_dir().ok_or("Could not determine home directory")?;

    let started = Local
        .timestamp_millis_opt(session.started_at)
        .single()
        .ok_or("Invalid session startedAt timestamp")?;

    let stamp = started.format("%Y-%m-%d-%H%M").to_string();

    let export_dir = home.join(format!("RapidReporter-{}", stamp));
    fs::create_dir_all(&export_dir).map_err(|e| e.to_string())?;

    assets::copy_icon_assets(&export_dir)?;

    let md_path = export_dir.join(format!("RapidReporter-{}.md", stamp));

    let mut md = String::new();
    md.push_str("# Rapid Reporter Session\n\n");

    if let Some(tester_display) = session
        .tester_name
        .as_deref()
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
    {
        md.push_str(&format!("- **Tester**: {}\n", tester_display));
    }

    md.push_str(&format!("- **Charter**: {}\n", session.charter.trim()));

    let tz_abbrev = started.format("%Z").to_string();
    let tz_display = if tz_abbrev == "+00:00" {
        "GMT"
    } else {
        &tz_abbrev
    };
    let date_display = started.format("%-d %B %Y").to_string();
    let time_display = started.format("%H:%M").to_string();
    let started_line = format!("{} {} {}", date_display, time_display, tz_display);
    md.push_str(&format!("- **Started**: {}\n", started_line));

    if let Some(mins) = session.duration_minutes {
        md.push_str(&format!("- **Duration**: {} minutes\n", mins));
    }

    md.push_str("\n");

    if let Some(summary_md) = markdown::build_summary_section(&session.notes) {
        md.push_str(&summary_md);
    }

    md.push_str("## Notes\n\n");

    for note in session.notes.iter().rev() {
        let text = note.text.trim();
        let note_type_lc = note.note_type.to_lowercase();

        let abs_path_opt: Option<String> = if note_type_lc == "screenshot" {
            Some(text.to_string())
        } else if let Some(rest) = text.strip_prefix("Screenshot:") {
            Some(rest.trim().to_string())
        } else {
            None
        };

        if let Some(abs_path) = abs_path_opt {
            match assets::copy_screenshot_asset(&export_dir, &abs_path) {
                Ok(rel_path) => {
                    md.push_str(&format!(
                        "<img src=\"{}\" width=\"900\" alt=\"Screenshot\">\n\n",
                        rel_path
                    ));
                }
                Err(err) => {
                    md.push_str(&format!("Screenshot (copy failed): {}\n\n", abs_path));
                    md.push_str(&format!("<!-- {} -->\n\n", err.replace("--", "- -")));
                }
            }

            continue;
        }

        if note_type_lc == "snippet" {
            md.push_str("```\n");
            md.push_str(text);
            md.push_str("\n```\n\n");
            continue;
        }

        let icon_filename = match note_type_lc.as_str() {
            "bug" => Some("bug.png"),
            "warning" => Some("warning.png"),
            "observation" => Some("observation.png"),
            "question" => Some("question.png"),
            "idea" => Some("idea.png"),
            _ => None,
        };

        if let Some(icon_file) = icon_filename {
            md.push_str(&format!(
                "<img src=\"assets/icons/{}\" width=\"50\" valign=\"middle\"> {}\n\n",
                icon_file, text
            ));
        } else {
            md.push_str(&format!("{}\n\n", text));
        }
    }

    let version = env!("CARGO_PKG_VERSION");
    md.push_str("---\n");
    md.push_str(&format!("Generated by Rapid Reporter v{}\n", version));

    fs::write(&md_path, md).map_err(|e| e.to_string())?;

    let mut result = HashMap::new();
    result.insert(
        "markdownPath".to_string(),
        md_path.to_string_lossy().to_string(),
    );

    Ok(result)
}
